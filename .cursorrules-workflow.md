# Workflow and Process Rules

**CRITICAL: Follow this process for quality results. Speed is not the goal - correctness is.**

---

## When You Receive a Task

### STEP 1: Analyze First (DON'T CODE YET)

**MANDATORY - Do not skip this step:**

Ask yourself:
1. **What problem am I actually solving?** (Understand the real requirement)
2. **Does similar code already exist?** (Search codebase thoroughly)
3. **What's the minimal change needed?** (Don't rebuild everything)
4. **What patterns does this project use?** (Look at referenced files)
5. **Are there edge cases I'm missing?** (Think through failure scenarios)
6. **What's the file structure?** (Check formatting rules)

**Search the codebase:**
- Use `codebase_search` for semantic searches
- Use `grep` for exact string/pattern matches
- Read similar files to understand patterns
- Check for existing utilities in shared locations

---

### STEP 2: Propose Approach (for non-trivial changes)

**For anything beyond simple 1-line fixes, tell me your plan first:**

```
## Proposed Approach

**Problem:** [Brief description of what needs to be solved]

**Existing Code Found:**
- Found similar logic in [file path]
- Can reuse [function/utility name] from [location]
- Pattern matches [other file] structure

**File Structure Check:**
- Target file uses [region structure]
- Main methods are in [location]
- Helpers are in [location]
- Will match this structure exactly

**Minimal Changes Needed:**
1. [Specific change to file X]
2. [Specific change to file Y]

**Will Reuse/Extract:**
- [Shared utility if creating new pattern]
- [Existing function/class]

**Will Extract to Shared:**
- [Utility/type] → [location] (to be used by X, Y, Z)

**Edge Cases to Handle:**
- [case 1]
- [case 2]

**Questions:**
- [Any uncertainties]

Proceed? Or would you prefer a different approach?
```

**Wait for approval before implementing.**

---

### STEP 3: Implement Minimally

**Once approved:**

- Make the **smallest possible change** that solves the problem
- Reuse existing code wherever possible
- Don't refactor unrelated code unless asked
- Stay within scope
- Match file structure exactly
- Extract constants (no magic numbers)
- Extract shared utilities (no duplication)

---

### STEP 4: Self-Review and Validation (MANDATORY)

**After implementing, ALWAYS review your work before submitting:**

#### A. Requirement Validation
- [ ] **Does this solve what was actually asked?** (Re-read the original request)
- [ ] **Did I understand the context correctly?** (Check if assumptions were correct)
- [ ] **Is the solution complete?** (All parts of the request addressed)
- [ ] **Are there any gaps?** (Missing edge cases, incomplete implementation)

#### B. Code Quality Validation
- [ ] **Function size:** No function > 50 lines (if larger, should be split)
- [ ] **Componentization:** Logic properly separated into focused methods
- [ ] **Helper files:** Reusable logic extracted to shared utilities
- [ ] **Readability:** Code is clear and self-explanatory
- [ ] **No duplication:** Repeated logic extracted to shared locations
- [ ] **Constants extracted:** No magic numbers, all configurable values extracted
- [ ] **Types extracted:** Complex structures defined once in shared location

#### C. File Structure Validation
- [ ] **Regions in correct order:** Private Variables → Main Methods → Render Methods → Helper Methods
- [ ] **Main methods first:** Override methods come before helper methods
- [ ] **Spacing/indentation:** Matches existing file exactly
- [ ] **Comment style:** Matches existing file exactly
- [ ] **Method grouping:** Matches existing pattern

#### D. Rule Adherence Check
- [ ] **Searched for existing code first:** Didn't duplicate existing functionality
- [ ] **Reused existing utilities:** Used shared helpers where possible
- [ ] **Minimal changes:** Only changed what was necessary
- [ ] **No unrequested features:** Didn't add extras
- [ ] **Stayed in scope:** Didn't refactor unrelated code

#### E. Solution Validation
- [ ] **Logic is correct:** Solution actually solves the problem
- [ ] **Edge cases handled:** Null checks, empty collections, boundary conditions
- [ ] **Error handling:** Appropriate error handling where needed
- [ ] **Performance:** No obvious performance issues introduced

**If any check fails, fix it before submitting.**

**Output your self-review:**
```
## Self-Review

✅ **Requirement:** [Confirms solution addresses the request]
✅ **Context:** [Confirms understanding was correct]
✅ **Code Quality:** [Function sizes, componentization, helpers - all good]
✅ **File Structure:** [Matches existing pattern]
✅ **Rules:** [All rules followed]

**Changes Made:**
- [File X] - [what changed, why]
- [File Y] - [what changed, why]

**Reused:**
- [Existing utility/pattern] from [location]

**Extracted:**
- [New utility] to [location] for reuse
```

---

## For Complex Changes (>100 lines or multi-file)

### Planning Phase (REQUIRED)

**Create a detailed plan:**

```
## Implementation Plan

**Files to modify:**
- [file 1] - [what changes, why]
- [file 2] - [what changes, why]

**New files needed:**
- [file] - [purpose, what it will contain]

**Existing code to reuse:**
- [function/file] - [what it does, how it will be used]

**Shared utilities to create:**
- [utility] - [location, to be used by X, Y, Z]

**Configuration to add:**
- [constant] - [current value hardcoded in N places, will extract to constant]

**File structure compliance:**
- Will match [reference file] structure
- Main methods before helpers
- Regions in correct order
```

**Wait for approval before implementing.**

---

## Response Format

### When Explaining Code:
- **Be concise** - no essays
- **Use examples** for clarity
- **Reference existing code** in the project when relevant

### When Providing Code:
- **Use proper markdown** with language identifier
- **Show complete, runnable code** - not snippets missing context
- **Indicate file paths** clearly
- **Highlight what's new vs what's reused**

### When Proposing Changes:
- **Always show the plan first** (for non-trivial changes)
- **Reference existing patterns** you found
- **Explain why** you're making each change
- **Ask questions** if uncertain

---

## Quality Over Speed

**Remember:**
- Taking time to analyze = fewer iterations
- Proposing approach = catches issues early
- Matching patterns = consistent codebase
- Extracting utilities = reusable solutions

**It's better to:**
- Spend 2 minutes analyzing → get it right first time
- Than spend 30 seconds coding → need 3 revisions

---

END OF WORKFLOW RULES
